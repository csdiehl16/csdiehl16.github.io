---
---

<div class="box-border p-4 min-h-screen w-[calc(100%-32px)] rounded-lg mx-4 text-main relative overflow-hidden">
    <!-- Animated Canvas Background -->
    <canvas id="profileCanvas" class="absolute inset-0 w-full h-full object-cover rounded-lg"></canvas>

    <!-- Overlay for better text readability -->


    <!-- Content -->
    <div class="mt-8 max-w-xl flex flex-col gap-4 relative z-10">
        <h2 class="font-semibold text-3xl md:text-4xl  text-gray-300">Hi, I'm </h2>
        <h1 class="text-6xl md:text-8xl font-bold text-main">Caleb Diehl</h1>

        <div class="glass-cyan flex flex-col gap-4">
          <div class='grid grid-cols-[15px_1fr] gap-2 items-center'>
            <svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M7.5 0.875C5.49797 0.875 3.875 2.49797 3.875 4.5C3.875 6.15288 4.98124 7.54738 6.49373 7.98351C5.2997 8.12901 4.27557 8.55134 3.50407 9.31167C2.52216 10.2794 2.02502 11.72 2.02502 13.5999C2.02502 13.8623 2.23769 14.0749 2.50002 14.0749C2.76236 14.0749 2.97502 13.8623 2.97502 13.5999C2.97502 11.8799 3.42786 10.7206 4.17091 9.9883C4.91536 9.25463 6.02674 8.87499 7.49995 8.87499C8.97317 8.87499 10.0846 9.25463 10.8291 9.98831C11.5721 10.7206 12.025 11.8799 12.025 13.5999C12.025 13.8623 12.2376 14.0749 12.5 14.0749C12.7623 14.075 12.975 13.8623 12.975 13.6C12.975 11.72 12.4778 10.2794 11.4959 9.31166C10.7244 8.55135 9.70025 8.12903 8.50625 7.98352C10.0187 7.5474 11.125 6.15289 11.125 4.5C11.125 2.49797 9.50203 0.875 7.5 0.875ZM4.825 4.5C4.825 3.02264 6.02264 1.825 7.5 1.825C8.97736 1.825 10.175 3.02264 10.175 4.5C10.175 5.97736 8.97736 7.175 7.5 7.175C6.02264 7.175 4.825 5.97736 4.825 4.5Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg>
            <p class="font-semibold text-gray-200">Frontend Engineer + Data Visualization Developer</p>
          </div>

          <div class="grid grid-cols-[15px_1fr] gap-2 items-start">
            <svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.85357 3.85355L7.65355 3.05353C8.2981 2.40901 9.42858 1.96172 10.552 1.80125C11.1056 1.72217 11.6291 1.71725 12.0564 1.78124C12.4987 1.84748 12.7698 1.97696 12.8965 2.10357C13.0231 2.23018 13.1526 2.50125 13.2188 2.94357C13.2828 3.37086 13.2779 3.89439 13.1988 4.44801C13.0383 5.57139 12.591 6.70188 11.9464 7.34645L7.49999 11.7929L6.35354 10.6465C6.15827 10.4512 5.84169 10.4512 5.64643 10.6465C5.45117 10.8417 5.45117 11.1583 5.64643 11.3536L7.14644 12.8536C7.34171 13.0488 7.65829 13.0488 7.85355 12.8536L8.40073 12.3064L9.57124 14.2572C9.65046 14.3893 9.78608 14.4774 9.9389 14.4963C10.0917 14.5151 10.2447 14.4624 10.3535 14.3536L12.3535 12.3536C12.4648 12.2423 12.5172 12.0851 12.495 11.9293L12.0303 8.67679L12.6536 8.05355C13.509 7.19808 14.0117 5.82855 14.1887 4.58943C14.2784 3.9618 14.2891 3.33847 14.2078 2.79546C14.1287 2.26748 13.9519 1.74482 13.6035 1.39645C13.2552 1.04809 12.7325 0.871332 12.2045 0.792264C11.6615 0.710945 11.0382 0.721644 10.4105 0.8113C9.17143 0.988306 7.80189 1.491 6.94644 2.34642L6.32322 2.96968L3.07071 2.50504C2.91492 2.48278 2.75773 2.53517 2.64645 2.64646L0.646451 4.64645C0.537579 4.75533 0.484938 4.90829 0.50375 5.0611C0.522563 5.21391 0.61073 5.34954 0.742757 5.42876L2.69364 6.59928L2.14646 7.14645C2.0527 7.24022 2.00002 7.3674 2.00002 7.50001C2.00002 7.63261 2.0527 7.75979 2.14646 7.85356L3.64647 9.35356C3.84173 9.54883 4.15831 9.54883 4.35357 9.35356C4.54884 9.1583 4.54884 8.84172 4.35357 8.64646L3.20712 7.50001L3.85357 6.85356L6.85357 3.85355ZM10.0993 13.1936L9.12959 11.5775L11.1464 9.56067L11.4697 11.8232L10.0993 13.1936ZM3.42251 5.87041L5.43935 3.85356L3.17678 3.53034L1.80638 4.90074L3.42251 5.87041ZM2.35356 10.3535C2.54882 10.1583 2.54882 9.8417 2.35356 9.64644C2.1583 9.45118 1.84171 9.45118 1.64645 9.64644L0.646451 10.6464C0.451188 10.8417 0.451188 11.1583 0.646451 11.3535C0.841713 11.5488 1.1583 11.5488 1.35356 11.3535L2.35356 10.3535ZM3.85358 11.8536C4.04884 11.6583 4.04885 11.3417 3.85359 11.1465C3.65833 10.9512 3.34175 10.9512 3.14648 11.1465L1.14645 13.1464C0.95119 13.3417 0.951187 13.6583 1.14645 13.8535C1.34171 14.0488 1.65829 14.0488 1.85355 13.8536L3.85358 11.8536ZM5.35356 13.3535C5.54882 13.1583 5.54882 12.8417 5.35356 12.6464C5.1583 12.4512 4.84171 12.4512 4.64645 12.6464L3.64645 13.6464C3.45119 13.8417 3.45119 14.1583 3.64645 14.3535C3.84171 14.5488 4.1583 14.5488 4.35356 14.3535L5.35356 13.3535ZM9.49997 6.74881C10.1897 6.74881 10.7488 6.1897 10.7488 5.5C10.7488 4.8103 10.1897 4.25118 9.49997 4.25118C8.81026 4.25118 8.25115 4.8103 8.25115 5.5C8.25115 6.1897 8.81026 6.74881 9.49997 6.74881Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg>
            <p class="text-gray-300 -mt-1">
              I'm a front-end developer with expertise in{" "}
              <strong>data visualization</strong>, <strong>interaction design</strong> and{" "}
              <strong>geospatial analysis.</strong>{" "}
            </p>
          </div>

          <div class='grid grid-cols-[15px_1fr] gap-2 items-start'>
            <svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 3.25C1 3.11193 1.11193 3 1.25 3H13.75C13.8881 3 14 3.11193 14 3.25V10.75C14 10.8881 13.8881 11 13.75 11H1.25C1.11193 11 1 10.8881 1 10.75V3.25ZM1.25 2C0.559643 2 0 2.55964 0 3.25V10.75C0 11.4404 0.559644 12 1.25 12H5.07341L4.82991 13.2986C4.76645 13.6371 5.02612 13.95 5.37049 13.95H9.62951C9.97389 13.95 10.2336 13.6371 10.1701 13.2986L9.92659 12H13.75C14.4404 12 15 11.4404 15 10.75V3.25C15 2.55964 14.4404 2 13.75 2H1.25ZM9.01091 12H5.98909L5.79222 13.05H9.20778L9.01091 12Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg>
            <p class="text-gray-300 -mt-1">
              Currently, I am a solutions engineer at Observable, the leading company for custom data viz. Before that, I was the interactive news editor at The Associated Press, where I oversaw data visualization, front-end development and interactive mapping for journalism viewed by millions across the globe.
            </p>
          </div>
        </div>
    </div>
</div>

<script>
    function initializeCanvas() {
      console.log('canvas initializing')
        const canvas = document.getElementById('profileCanvas') as HTMLCanvasElement;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        // Set up responsive canvas
        function resizeCanvas() {
           if (!canvas || !ctx) return;
            const rect = canvas.getBoundingClientRect();
            const devicePixelRatio = window.devicePixelRatio || 1;

            canvas.width = rect.width * devicePixelRatio;
            canvas.height = rect.height * devicePixelRatio;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            ctx.scale(devicePixelRatio, devicePixelRatio);
        }

        // Initial resize
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const width = canvas.offsetWidth;
        const height = canvas.offsetHeight;

        let points: number[][] = [];
        let currentPatternIndex = 0;
        let isTransitioning = false;
        let animationId: number;

        const patternFunctions = [
            generateSpiral,
            generateClusters,
            generateWaves,
            generateVortex,
            generateGrid
        ];

        function generateSpiral() {
            const points = [];
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) * 0.4;
            const numPoints = 1200 + Math.random() * 800;
            const rotations = 5 + Math.random() * 3;

            for (let i = 0; i < numPoints; i++) {
                const t = i / numPoints;
                const angle = t * Math.PI * rotations;
                const radius = t * maxRadius;
                const noise = (Math.random() - 0.5) * 25;

                const x = centerX + Math.cos(angle) * radius + noise;
                const y = centerY + Math.sin(angle) * radius + noise;

                if (x > 15 && x < width - 15 && y > 15 && y < height - 15) {
                    points.push([x, y]);
                }
            }

            return points;
        }

        function generateClusters() {
            const points = [];
            const numPoints = 1000 + Math.random() * 600;
            const numClusters = 4 + Math.floor(Math.random() * 3);
            const pointsPerCluster = Math.floor(numPoints / numClusters);

            for (let c = 0; c < numClusters; c++) {
                const centerX = 120 + Math.random() * (width - 240);
                const centerY = 120 + Math.random() * (height - 240);
                const clusterRadius = 70 + Math.random() * 90;

                for (let i = 0; i < pointsPerCluster; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * clusterRadius;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;

                    if (x > 15 && x < width - 15 && y > 15 && y < height - 15) {
                        points.push([x, y]);
                    }
                }
            }

            return points;
        }

        function generateWaves() {
            const points = [];
            const numPoints = 800 + Math.random() * 600;
            const waves = 4 + Math.floor(Math.random() * 2);
            const amplitude = 50 + Math.random() * 70;
            const frequency = 3 + Math.random() * 2;

            for (let i = 0; i < numPoints; i++) {
                const x = Math.random() * (width - 40) + 20;
                const waveIndex = Math.floor(Math.random() * waves);
                const baseY = (height / (waves + 1)) * (waveIndex + 1);
                const waveY = baseY + Math.sin((x / width) * Math.PI * frequency) * amplitude;
                const noise = (Math.random() - 0.5) * 50;

                const y = waveY + noise;

                if (y > 15 && y < height - 15) {
                    points.push([x, y]);
                }
            }

            return points;
        }

        function generateVortex() {
            const points = [];
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) * 0.45;
            const numPoints = 1000 + Math.random() * 600;
            const spiralTightness = 7 + Math.random() * 5;

            for (let i = 0; i < numPoints; i++) {
                const t = i / numPoints;
                const radius = t * maxRadius;
                const angle = t * Math.PI * spiralTightness + Math.sin(t * Math.PI * 5) * 1.3;
                const noise = (Math.random() - 0.5) * 35;

                const x = centerX + Math.cos(angle) * radius + noise;
                const y = centerY + Math.sin(angle) * radius + noise;

                if (x > 15 && x < width - 15 && y > 15 && y < height - 15) {
                    points.push([x, y]);
                }
            }

            return points;
        }

        function generateGrid() {
            const points = [];
            const numPoints = 800 + Math.random() * 600;
            const gridSize = Math.sqrt((width * height) / numPoints) * 1.1;
            const jitter = gridSize * (0.4 + Math.random() * 0.3);

            for (let x = 50; x < width - 50; x += gridSize) {
                for (let y = 50; y < height - 50; y += gridSize) {
                    const jitterX = (Math.random() - 0.5) * jitter;
                    const jitterY = (Math.random() - 0.5) * jitter;
                    points.push([x + jitterX, y + jitterY]);
                }
            }

            return points;
        }

        const startColor = { r: 100, g: 200, b: 220 };
        const endColor = { r: 41, g: 58, b: 78 };

        function drawTriangulation(targetPoints: number[][], lineOpacity = 1) {
            if (targetPoints.length < 3 || !ctx) return;

            // Clear canvas with dark background
            ctx.clearRect(0, 0, width, height);

            try {
                // Use d3.Delaunay if available
                if (typeof (globalThis as any).d3 !== 'undefined' && (globalThis as any).d3.Delaunay) {
                    const delaunay = (globalThis as any).d3.Delaunay.from(targetPoints);
                    const triangles = delaunay.triangles;

                    const baseOpacity = Math.max(0.4, Math.min(.8, 250 / targetPoints.length));

                    ctx.lineWidth = 0.6;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    // Draw triangles
                    for (let i = 0; i < triangles.length; i += 3) {
                        const p1 = targetPoints[triangles[i]];
                        const p2 = targetPoints[triangles[i + 1]];
                        const p3 = targetPoints[triangles[i + 2]];

                        if (!p1 || !p2 || !p3) continue;

                        // Calculate opacity based on distance from center
                        const centerX = (p1[0] + p2[0] + p3[0]) / 3;
                        const centerY = (p1[1] + p2[1] + p3[1]) / 3;
                        const distanceFromCenter = Math.sqrt(
                            Math.pow(centerX - width / 2, 2) + Math.pow(centerY - height / 2, 2)
                        );
                        const maxDistance = Math.sqrt(Math.pow(width / 2, 2) + Math.pow(height / 2, 2));
                        const distanceFactor = 1 - (distanceFromCenter / maxDistance) * 0.4;

                        const finalOpacity = baseOpacity * distanceFactor * lineOpacity;

                        // Create gradient colors from cyan to pink

                        const colorT = (centerX / width + centerY / height) / 2;
                        const r = Math.floor(startColor.r + colorT * (endColor.r - startColor.r)); // cyan to pink red
                        const g = Math.floor(startColor.g + colorT * (endColor.g - startColor.g)); // cyan to pink green
                        const b = Math.floor(startColor.b + colorT * (endColor.b - startColor.b)); // cyan to pink blue

                        // Fill triangles with gradient colors
                        const fillOpacity = finalOpacity * 0.5;
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${fillOpacity})`;
                        ctx.beginPath();
                        ctx.moveTo(p1[0], p1[1]);
                        ctx.lineTo(p2[0], p2[1]);
                        ctx.lineTo(p3[0], p3[1]);
                        ctx.closePath();
                        ctx.fill();

                        // Draw triangle outline
                        if (lineOpacity > 0.05) {
                            ctx.lineWidth = 1;
                            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${.2})`;
                            ctx.beginPath();
                            ctx.moveTo(p1[0], p1[1]);
                            ctx.lineTo(p2[0], p2[1]);
                            ctx.lineTo(p3[0], p3[1]);
                            ctx.closePath();
                            ctx.stroke();
                        }
                    }
                }

                // Draw points with gradient colors
                for (let point of targetPoints) {
                    const distanceFromCenter = Math.sqrt(
                        Math.pow(point[0] - width / 2, 2) + Math.pow(point[1] - height / 2, 2)
                    );
                    const maxDistance = Math.sqrt(Math.pow(width / 2, 2) + Math.pow(height / 2, 2));
                    const pointOpacity = (1 - (distanceFromCenter / maxDistance) * 0.3) * 0.8;

                    const colorT = (point[0] / width + point[1] / height) / 2;
                    const r = Math.floor(startColor.r + colorT * (endColor.r - startColor.r));
                    const g = Math.floor(startColor.g + colorT * (endColor.g - startColor.g));
                    const b = Math.floor(startColor.b + colorT * (endColor.b - startColor.b));

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${.2})`;
                    ctx.arc(point[0], point[1], 8, 0, Math.PI * 2);
                     ctx.fill();

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${pointOpacity})`;
                    ctx.beginPath();
                    ctx.arc(point[0], point[1], 2, 0, Math.PI * 2);
                    ctx.fill();


                }
            } catch (e) {
                console.error('Error drawing triangulation:', e);
            }
        }

        function interpolatePoints(oldPoints: number[][], newPoints: number[][], progress: number) {
            const targetLength = Math.max(oldPoints.length, newPoints.length);
            const interpolated = [];

            for (let i = 0; i < targetLength; i++) {
                let oldPoint, newPoint;

                if (i < oldPoints.length) {
                    oldPoint = oldPoints[i];
                } else {
                    oldPoint = [width / 2, height / 2];
                }

                if (i < newPoints.length) {
                    newPoint = newPoints[i];
                } else {
                    newPoint = [width / 2, height / 2];
                }

                const x = oldPoint[0] + (newPoint[0] - oldPoint[0]) * progress;
                const y = oldPoint[1] + (newPoint[1] - oldPoint[1]) * progress;

                interpolated.push([x, y]);
            }

            return interpolated;
        }

        function morphPattern() {
            if (isTransitioning) return;

            isTransitioning = true;
            const oldPoints = [...points];

            currentPatternIndex = (currentPatternIndex + 1) % patternFunctions.length;
            const newPoints = patternFunctions[Math.floor(Math.random() * patternFunctions.length)]();

            let progress = 0;
            const transitionDuration = 3000; // 4 seconds
            const startTime = Date.now();

            function animateTransition() {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / transitionDuration, 1);

                const easedProgress = 1 - Math.pow(1 - progress, 3);
                const interpolatedPoints = interpolatePoints(oldPoints, newPoints, easedProgress);

                drawTriangulation(interpolatedPoints, 1);

                if (progress < 1) {
                    animationId = requestAnimationFrame(animateTransition);
                } else {
                    points = newPoints;
                    isTransitioning = false;
                }
            }

            animateTransition();
        }

        // Initialize with spiral pattern
        points = generateSpiral();
        drawTriangulation(points);

        // Variable to hold the interval ID
        morphPattern()
        const morphInterval = setInterval(morphPattern, 5000);

        // Cleanup function to prevent memory leaks
        const cleanup = () => {
            if (morphInterval) {
                clearInterval(morphInterval);
            }
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            window.removeEventListener('resize', resizeCanvas);
        };

        // Clean up when navigating away
        document.addEventListener('astro:before-swap', cleanup, { once: true });

        // Load D3.js for Delaunay triangulation
        if (typeof (globalThis as any).d3 === 'undefined') {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js';
            script.onload = function() {
                // Redraw with D3 loaded
                drawTriangulation(points);
            };
            document.head.appendChild(script);
        }
    }

    // Initialize on first load and after each view transition
    document.addEventListener('astro:page-load', initializeCanvas);
</script>
