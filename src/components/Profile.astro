---
---

<div class="box-border p-4 min-h-screen w-[calc(100%-32px)] rounded-lg mx-4 text-main relative overflow-hidden">
    <!-- Animated Canvas Background -->
    <canvas id="profileCanvas" class="absolute inset-0 w-full h-full object-cover rounded-lg"></canvas>

    <!-- Overlay for better text readability -->


    <!-- Content -->
    <div class="mt-8 max-w-xl flex flex-col gap-4 relative z-10">
        <h2 class="font-bold text-3xl md:text-4xl  text-gray-300">Hi, I'm </h2>
        <h1 class="text-6xl md:text-8xl text-main">Caleb Diehl</h1>

        <div class="flex flex-col gap-4 bg-muted/20 backdrop-blur-md border border-white/20 shadow-xl p-4 rounded-lg">
            <p class="font-bold">Frontend Engineer + Data Visualization Developer</p>
            <p class="text-gray-300">
                I'm a front-end developer with expertise in{" "}
                <strong>data visualization</strong>, <strong>interaction design</strong> and{" "}
                <strong>geospatial analysis.</strong>{" "}Currently, I am a solutions engineer at Observable, the leading company for custom data viz. Before that, I was the interactive news editor at The Associated Press, where I oversaw data visualization, front-end development and interactive mapping for journalism viewed by millions across the globe.
            </p>
        </div>
    </div>
</div>

<script>
    function initializeCanvas() {
      console.log('canvas initializing')
        const canvas = document.getElementById('profileCanvas') as HTMLCanvasElement;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        // Set up responsive canvas
        function resizeCanvas() {
           if (!canvas || !ctx) return;
            const rect = canvas.getBoundingClientRect();
            const devicePixelRatio = window.devicePixelRatio || 1;

            canvas.width = rect.width * devicePixelRatio;
            canvas.height = rect.height * devicePixelRatio;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            ctx.scale(devicePixelRatio, devicePixelRatio);
        }

        // Initial resize
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const width = canvas.offsetWidth;
        const height = canvas.offsetHeight;

        let points: number[][] = [];
        let currentPatternIndex = 0;
        let isTransitioning = false;
        let animationId: number;

        const patternFunctions = [
            generateSpiral,
            generateClusters,
            generateWaves,
            generateVortex,
            generateGrid
        ];

        function generateSpiral() {
            const points = [];
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) * 0.4;
            const numPoints = 1200 + Math.random() * 800;
            const rotations = 5 + Math.random() * 3;

            for (let i = 0; i < numPoints; i++) {
                const t = i / numPoints;
                const angle = t * Math.PI * rotations;
                const radius = t * maxRadius;
                const noise = (Math.random() - 0.5) * 25;

                const x = centerX + Math.cos(angle) * radius + noise;
                const y = centerY + Math.sin(angle) * radius + noise;

                if (x > 15 && x < width - 15 && y > 15 && y < height - 15) {
                    points.push([x, y]);
                }
            }

            return points;
        }

        function generateClusters() {
            const points = [];
            const numPoints = 1000 + Math.random() * 600;
            const numClusters = 4 + Math.floor(Math.random() * 3);
            const pointsPerCluster = Math.floor(numPoints / numClusters);

            for (let c = 0; c < numClusters; c++) {
                const centerX = 120 + Math.random() * (width - 240);
                const centerY = 120 + Math.random() * (height - 240);
                const clusterRadius = 70 + Math.random() * 90;

                for (let i = 0; i < pointsPerCluster; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * clusterRadius;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;

                    if (x > 15 && x < width - 15 && y > 15 && y < height - 15) {
                        points.push([x, y]);
                    }
                }
            }

            return points;
        }

        function generateWaves() {
            const points = [];
            const numPoints = 800 + Math.random() * 600;
            const waves = 4 + Math.floor(Math.random() * 2);
            const amplitude = 50 + Math.random() * 70;
            const frequency = 3 + Math.random() * 2;

            for (let i = 0; i < numPoints; i++) {
                const x = Math.random() * (width - 40) + 20;
                const waveIndex = Math.floor(Math.random() * waves);
                const baseY = (height / (waves + 1)) * (waveIndex + 1);
                const waveY = baseY + Math.sin((x / width) * Math.PI * frequency) * amplitude;
                const noise = (Math.random() - 0.5) * 50;

                const y = waveY + noise;

                if (y > 15 && y < height - 15) {
                    points.push([x, y]);
                }
            }

            return points;
        }

        function generateVortex() {
            const points = [];
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) * 0.45;
            const numPoints = 1000 + Math.random() * 600;
            const spiralTightness = 7 + Math.random() * 5;

            for (let i = 0; i < numPoints; i++) {
                const t = i / numPoints;
                const radius = t * maxRadius;
                const angle = t * Math.PI * spiralTightness + Math.sin(t * Math.PI * 5) * 1.3;
                const noise = (Math.random() - 0.5) * 35;

                const x = centerX + Math.cos(angle) * radius + noise;
                const y = centerY + Math.sin(angle) * radius + noise;

                if (x > 15 && x < width - 15 && y > 15 && y < height - 15) {
                    points.push([x, y]);
                }
            }

            return points;
        }

        function generateGrid() {
            const points = [];
            const numPoints = 800 + Math.random() * 600;
            const gridSize = Math.sqrt((width * height) / numPoints) * 1.1;
            const jitter = gridSize * (0.4 + Math.random() * 0.3);

            for (let x = 50; x < width - 50; x += gridSize) {
                for (let y = 50; y < height - 50; y += gridSize) {
                    const jitterX = (Math.random() - 0.5) * jitter;
                    const jitterY = (Math.random() - 0.5) * jitter;
                    points.push([x + jitterX, y + jitterY]);
                }
            }

            return points;
        }

        const startColor = { r: 100, g: 200, b: 220 };
        const endColor = { r: 41, g: 58, b: 78 };

        function drawTriangulation(targetPoints: number[][], lineOpacity = 1) {
            if (targetPoints.length < 3 || !ctx) return;

            // Clear canvas with dark background
            ctx.clearRect(0, 0, width, height);

            try {
                // Use d3.Delaunay if available
                if (typeof (globalThis as any).d3 !== 'undefined' && (globalThis as any).d3.Delaunay) {
                    const delaunay = (globalThis as any).d3.Delaunay.from(targetPoints);
                    const triangles = delaunay.triangles;

                    const baseOpacity = Math.max(0.4, Math.min(.8, 250 / targetPoints.length));

                    ctx.lineWidth = 0.6;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    // Draw triangles
                    for (let i = 0; i < triangles.length; i += 3) {
                        const p1 = targetPoints[triangles[i]];
                        const p2 = targetPoints[triangles[i + 1]];
                        const p3 = targetPoints[triangles[i + 2]];

                        if (!p1 || !p2 || !p3) continue;

                        // Calculate opacity based on distance from center
                        const centerX = (p1[0] + p2[0] + p3[0]) / 3;
                        const centerY = (p1[1] + p2[1] + p3[1]) / 3;
                        const distanceFromCenter = Math.sqrt(
                            Math.pow(centerX - width / 2, 2) + Math.pow(centerY - height / 2, 2)
                        );
                        const maxDistance = Math.sqrt(Math.pow(width / 2, 2) + Math.pow(height / 2, 2));
                        const distanceFactor = 1 - (distanceFromCenter / maxDistance) * 0.4;

                        const finalOpacity = baseOpacity * distanceFactor * lineOpacity;

                        // Create gradient colors from cyan to pink

                        const colorT = (centerX / width + centerY / height) / 2;
                        const r = Math.floor(startColor.r + colorT * (endColor.r - startColor.r)); // cyan to pink red
                        const g = Math.floor(startColor.g + colorT * (endColor.g - startColor.g)); // cyan to pink green
                        const b = Math.floor(startColor.b + colorT * (endColor.b - startColor.b)); // cyan to pink blue

                        // Fill triangles with gradient colors
                        const fillOpacity = finalOpacity * 0.3;
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${fillOpacity})`;
                        ctx.beginPath();
                        ctx.moveTo(p1[0], p1[1]);
                        ctx.lineTo(p2[0], p2[1]);
                        ctx.lineTo(p3[0], p3[1]);
                        ctx.closePath();
                        ctx.fill();

                        // Draw triangle outline
                        if (lineOpacity > 0.05) {
                            ctx.lineWidth = 1;
                            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${finalOpacity})`;
                            ctx.beginPath();
                            ctx.moveTo(p1[0], p1[1]);
                            ctx.lineTo(p2[0], p2[1]);
                            ctx.lineTo(p3[0], p3[1]);
                            ctx.closePath();
                            ctx.stroke();
                        }
                    }
                }

                // Draw points with gradient colors
                for (let point of targetPoints) {
                    const distanceFromCenter = Math.sqrt(
                        Math.pow(point[0] - width / 2, 2) + Math.pow(point[1] - height / 2, 2)
                    );
                    const maxDistance = Math.sqrt(Math.pow(width / 2, 2) + Math.pow(height / 2, 2));
                    const pointOpacity = (1 - (distanceFromCenter / maxDistance) * 0.3) * 0.8;

                    const colorT = (point[0] / width + point[1] / height) / 2;
                    const r = Math.floor(startColor.r + colorT * (endColor.r - startColor.r));
                    const g = Math.floor(startColor.g + colorT * (endColor.g - startColor.g));
                    const b = Math.floor(startColor.b + colorT * (endColor.b - startColor.b));

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${.2})`;
                    ctx.arc(point[0], point[1], 8, 0, Math.PI * 2);
                     ctx.fill();

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${pointOpacity})`;
                    ctx.beginPath();
                    ctx.arc(point[0], point[1], 2, 0, Math.PI * 2);
                    ctx.fill();


                }
            } catch (e) {
                console.error('Error drawing triangulation:', e);
            }
        }

        function interpolatePoints(oldPoints: number[][], newPoints: number[][], progress: number) {
            const targetLength = Math.max(oldPoints.length, newPoints.length);
            const interpolated = [];

            for (let i = 0; i < targetLength; i++) {
                let oldPoint, newPoint;

                if (i < oldPoints.length) {
                    oldPoint = oldPoints[i];
                } else {
                    oldPoint = [width / 2, height / 2];
                }

                if (i < newPoints.length) {
                    newPoint = newPoints[i];
                } else {
                    newPoint = [width / 2, height / 2];
                }

                const x = oldPoint[0] + (newPoint[0] - oldPoint[0]) * progress;
                const y = oldPoint[1] + (newPoint[1] - oldPoint[1]) * progress;

                interpolated.push([x, y]);
            }

            return interpolated;
        }

        function morphPattern() {
            if (isTransitioning) return;

            isTransitioning = true;
            const oldPoints = [...points];

            currentPatternIndex = (currentPatternIndex + 1) % patternFunctions.length;
            const newPoints = patternFunctions[Math.floor(Math.random() * patternFunctions.length)]();

            let progress = 0;
            const transitionDuration = 3000; // 4 seconds
            const startTime = Date.now();

            function animateTransition() {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / transitionDuration, 1);

                const easedProgress = 1 - Math.pow(1 - progress, 3);
                const interpolatedPoints = interpolatePoints(oldPoints, newPoints, easedProgress);

                drawTriangulation(interpolatedPoints, 1);

                if (progress < 1) {
                    animationId = requestAnimationFrame(animateTransition);
                } else {
                    points = newPoints;
                    isTransitioning = false;
                }
            }

            animateTransition();
        }

        // Initialize with spiral pattern
        points = generateSpiral();
        drawTriangulation(points);

        // Variable to hold the interval ID
        morphPattern()
        const morphInterval = setInterval(morphPattern, 5000);

        // Cleanup function to prevent memory leaks
        const cleanup = () => {
            if (morphInterval) {
                clearInterval(morphInterval);
            }
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            window.removeEventListener('resize', resizeCanvas);
        };

        // Clean up when navigating away
        document.addEventListener('astro:before-swap', cleanup, { once: true });

        // Load D3.js for Delaunay triangulation
        if (typeof (globalThis as any).d3 === 'undefined') {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js';
            script.onload = function() {
                // Redraw with D3 loaded
                drawTriangulation(points);
            };
            document.head.appendChild(script);
        }
    }

    // Initialize on first load and after each view transition
    document.addEventListener('astro:page-load', initializeCanvas);
</script>
